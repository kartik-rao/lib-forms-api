enum FilterWith {
  AND
  OR
}

enum NumericFilterExpression {
  in
  ne
  eq
  le
  lt
  ge
  gt
  between
  notBetween
  isNull
  isNotNull
}

enum BooleanFilterExpression {
  ne
  eq
}

enum StringFilterExpression {
  ne
  eq
  contains
  notContains
  startsWith
  isNull
  isNotNull
  in
}

input DateFilter {
  with  : FilterWith
  expression: NumericFilterExpression!
  value: [AWSDateTime!]
}

input BooleanFilter {
  with  : FilterWith
  expression: BooleanFilterExpression!
  value: [Boolean!]
}

input FloatFilter {
  with  : FilterWith
  expression: NumericFilterExpression!
  value: [Float!]
}


input IntFilter {
  with  : FilterWith
  expression: NumericFilterExpression!
  value: [Int!]
}

input StringFilter {
  with  : FilterWith
  expression: StringFilterExpression!
  value: [String!]
}

input AccountFilterInput {
  name: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  planId: IntFilter
  active: IntFilter
  criteria: [AccountFilterInput!]
}

input UserFilterInput {
  accountId: StringFilter
  ownerId: IntFilter
  email: StringFilter
  userGroup: StringFilter
  given_name: StringFilter
  family_name: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  isDeleted: IntFilter
  criteria: [UserFilterInput!]
}

input PlanTypeFilterInput {
  ownerId: IntFilter
  cost: FloatFilter
  billingTerm: StringFilter
  name: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  isDeleted: IntFilter
  criteria: [PlanTypeFilterInput!]
}

input IntegrationTypeFilterInput {
  ownerId: IntFilter
  planTypeId: IntFilter
  name: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  active: IntFilter
  criteria: [IntegrationTypeFilterInput!]
}

input IntegrationFilterInput {
  ownerId: IntFilter
  accountId: IntFilter
  formId: IntFilter
  active: IntFilter
  isDeleted: IntFilter
  lastExecuted: DateFilter
  lastExecutionResult: IntFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  criteria: [IntegrationFilterInput!]
}

input FormFilterInput {
  name: StringFilter
  ownerId: IntFilter
  accountId: IntFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  startsAt: DateFilter
  endsAt: DateFilter
  isPaused: IntFilter
  isDeleted: IntFilter
  criteria: [FormFilterInput!]
}

input PlanFilterInput {
  accountId: IntFilter
  ownerId: IntFilter
  planTypeId: IntFilter
  lastBillDate: DateFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  startDate: DateFilter
  endDate: DateFilter
  criteria: [PlanFilterInput!]
}

type FormEntry @model {
  id: ID!
  formId: ID!
  form: Form!
  data: AWSJSON!
  createdAt: AWSDateTime!
}

input AddFormEntryInput {
  data: AWSJSON!
}

type FormVersion @model {
  id: ID!
  accountId: ID!
  formId: ID!
  ownerId: ID!
  ownedBy: User!
  createdAt: AWSDateTime
  notes: String
  formData: AWSJSON
}

input AddFormVersionInput {
  accountId: ID!
  formId: ID!
  notes: String
  formData: AWSJSON!
}


type Form @model  {
  id: ID!
  ownerId: ID!
  name: String!
  description: String!
  versionId: ID
  version: FormVersion
  ownedBy: User!
  accountId: ID!
  account: Account!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime
  startDate: AWSDateTime
  endDate  : AWSDateTime
  isPaused : Boolean
  isDeleted: Boolean
  versions(limit: Int): [FormVersion]
  integrations(limit: Int): [Integration]
  entries(limit: Int): [FormEntry]
}


input AddFormInput {
  accountId: ID!
  name: String!
  description: String!
  startsAt: AWSDateTime
  endsAt: AWSDateTime
  isPaused: Boolean
}

input UpdateFormInput {
  id: ID!
  currentVersionId: ID
  name: String
  description: String
  startsAt: AWSDateTime
  endsAt: AWSDateTime
  isPaused: Boolean
}

input DeleteFormInput {
  id: ID!
  accountId: ID!
}

type User @model {
  id: ID!
  ownerId: ID
  accountId: ID
  account: Account
  email: String!
  userGroup: String!
  given_name: String!
  family_name: String!
  phone_number: AWSPhone
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  isDeleted: Int
  numForms: Int
}


input UpdateUserInputData {
  group: String!
  given_name: String!
  family_name: String!
  phone_number: AWSPhone
}

input UpdateUserInput {
  id: ID!
  data: UpdateUserInputData!
}

enum AddressType {
  BILLING
  CONTACT
}

type Address @model {
  id: ID!
  name: String!
  addressee: String
  addressType: AddressType!
  phone_number: AWSPhone
  email: String!
  street: String
  city: String
  state: String
  country: String
}


type AddAddressInput {
  name: String!
  addressee: String
  addressType: AddressType!
  phone_number: AWSPhone
  email: String!
  street: String
  city: String
  state: String
  country: String
}

type Account @model {
  id: ID!
  name: String!
  addresses(limit: Int): [Address]
  website: String
  taxId: String
  ownerId: ID!
  ownedBy: User!
  plan : Plan
  planId: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  active: Int
  numForms: Int
  numUsers: Int
  users(limit: Int): [User]
  forms(limit: Int): [Form]
}

input UpdateAccountInput {
  id: ID!
  name: String
}
type PlanType @model {
  id: ID!
  ownerId: ID!
  ownedBy: User!
  name: String!
  cost: Float!
  active: Int!
  billingTerm: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  isDeleted: Int
}

input AddPlanTypeInput {
  name: String!
  cost: Float!
  billingTerm: String!
  active: Int!
}

input UpdatePlanTypeInput {
  id: ID!
  name: String
  cost: Float
  billingTerm: String
  active: Int
}

type Plan @model {
  id: ID!
  accountId: ID!
  account: Account!
  ownerId: ID!
  ownedBy: User!
  planTypeId: ID!
  startDate: AWSDateTime!
  endDate: AWSDateTime
  active: Int
  lastBillDate: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  planType: PlanType
  isDeleted: Int
}

input AddPlanInput {
  accountId: ID!
  planTypeId: ID!
  endDate: AWSDateTime
  active: Int
}

input UpdatePlanInput {
  planId: ID!
  accountId: ID!
  active: Int!
  endDate: AWSDateTime
}

type IntegrationType @model {
  id: ID!
  ownerId: ID!
  ownedBy: User!
  planTypeId: ID!
  planType: PlanType
  name: String!
  active: Int!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}


input AddIntegrationTypeInput {
  name: String!
  active: Int
}

input UpdateIntegrationTypeInput {
  id: ID!
  name: String!
  active: Int
}

type Integration @model {
  id: ID!
  integrationTypeId: ID!
  integrationType: IntegrationType
  ownerId: ID!
  accountId: ID!
  formId: ID!
  form: Form!
  active: Int!
  authType: String
  auth: AWSJSON
  target: String
  method: String
  lastExecuted: AWSDateTime
  lastExecutionResult: Int
  lastExecutionResultMessage: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  isDeleted: Int
}


input AddIntegrationInput {
  integrationTypeId: ID!
  accountId: ID!
  formId: ID!
  active: Int
  authType: String
  auth: AWSJSON
  target: String
  method: String
}

input UpdateIntegrationTypeInputData {
  active: Int
  authType: String
  auth: AWSJSON
  target: String
  method: String
}

input UpdateIntegrationInput {
  id: ID!
  active: Int
  authType: String
  auth: AWSJSON
  target: String
  method: String
}

input OffsetLimit {
  offset: Int
  limit: Int
}

type Query {
  getAccount(accountId: ID!): Account
  getUser(userId: ID!): User
  getPlan(planId: String!): Plan
  getActiveAccountPlan(accountId: String!): Plan
  getPlanType(planTypeId: String!): PlanType
  getForm(formId: String!) : Form
  getFormVersion(versionId: String!) : FormVersion
  getIntegrationType(integrationTypeId: String!): IntegrationType
  getIntegration(integrationId: String!): Integration
  getFormEntry(formEntryId: String!): FormEntry
  listAccounts(offsetLimit: OffsetLimit, filter: AccountFilterInput): [Account]
  listUsers(offsetLimit: OffsetLimit, filter: UserFilterInput) : [User]
  listPlans(offsetLimit: OffsetLimit, filter: PlanFilterInput): [Plan]
  listPlanTypes(offsetLimit: OffsetLimit, filter: PlanTypeFilterInput): [PlanType]
  listForms(offsetLimit: OffsetLimit, filter: FormFilterInput) : [Form]
  listIntegrationTypes(offsetLimit: OffsetLimit, filter: IntegrationTypeFilterInput): [IntegrationType]
  listIntegrations(offsetLimit: OffsetLimit, filter: IntegrationFilterInput): [Integration]
  listFormEntries(offsetLimit: OffsetLimit, formId: String!) : [FormEntry]
  listFormEntriesByTime(offsetLimit: OffsetLimit, formId: String!, timestampPrefix: String!): [FormEntry]
}

type Mutation {
  addPlanType(input: AddPlanTypeInput): PlanType!
  addPlan(input: AddPlanInput): Plan!
  addIntegrationType(input: AddIntegrationTypeInput): IntegrationType!
  addIntegration(input: AddIntegrationInput): Integration!
  addForm(input: AddFormInput!): Form!
  addFormVersion(input: AddFormVersionInput): Form!

  updatePlanType(input: UpdatePlanTypeInput): PlanType!
  updatePlan(input: UpdatePlanInput): Plan!
  updateAccount(input: UpdateAccountInput): Account!
  updateAccountPlan(input: AddPlanInput): Account!
  updateUser(input: UpdateUserInput): User!
  updateIntegrationType(input: UpdateIntegrationTypeInput): IntegrationType!
  updateIntegration(input: UpdateIntegrationInput): Integration!
  updateForm(input: UpdateFormInput): Form!

  deleteForm(input: DeleteFormInput): Form!
  deletePlanType(planTypeId: ID!): PlanType!
  deletePlan(accountId: ID!, planId: ID!): Plan!
  deleteAccount(accountId: ID!): Account!
  deleteUser(userId: ID!): User!
  deleteIntegrationType(integrationTypeId: ID!): IntegrationType!
  deleteIntegration(integrationId: ID!): Integration!

  addFormEntry(input: AddFormEntryInput!): FormEntry!
}

schema {
  query: Query
  mutation: Mutation
}
